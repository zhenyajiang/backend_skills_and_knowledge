# JVM常见垃圾回收核心算法
## 标记算法
#### 引用可达算法
#### 引用计数算法

## 回收算法
#### 复制算法

```
JVM中，Parellel Scavenge, G1使用到了复制算法来回收年轻代
```

扩展解读：年轻代之所以使用复制算法，是因为年轻代的对象95%都会被回收。剩下的5%使用复制算法开销不大。

#### 标记整理算法
分为标记和整理两阶段。
1.一阶段同标记清除。
2.清除“未存活”对象之前，先将“已存活”对象整理到内存的一端。
优点：可以部分解决内存碎片问题。提高内存使用率。
缺点：慢。因为会移动对象。

```
JVM中，Parellel Old 和G1使用了标记整理算法回收老年代
```
#### 标记清除算法
分为标记和清除两阶段。
1.遍历整个堆，使用可达算法标记可达对象，标记他们为“存活”。
2.遍历整个堆，清除“未存活”对象。

```
JVM中，Serial Old 和CMS使用了标记清除算法
```

优点：实现简单，比标记整理要快。因为不会移动对象。
缺点：如果回收的对象多，可能会导致大片空余的内存碎片。
     两次遍历整个堆。

# JVM常见垃圾回收器组合
## Serial + Serial Old 
适合单线程场景
## ParNew + CMS + Serial Old
适合需要短暂停顿的（保证低延迟）

## Parellel Scavenge + Parellel Old 
Java 8默认垃圾回收器，这种组合优先追求高吞吐量。即有可能减少垃圾回收停顿时间来保障吞吐量。

## G1
低于两G的内存不建议使用G1，因为G1会将内存最多分为2048个region。每个region在1MB到32MB之间。
最小堆内存为：1MB * 2048 = 2GB。

```
低延迟适合如:实时交易系统
高吞吐量适合如：批处理系统。高吞吐量其实就是尽可能减少停顿时间，尽量保证代码运行时间足够长。

要实现高吞吐量，系统可能需要并行处理多个请求或任务，这可能会增加系统的复杂性和资源争用，从而导致延迟增加。另一方面，要实现低延迟，系统可能需要优化单个请求或任务的处理流程，这可能会限制系统的并行处理能力，从而影响吞吐量。
```


## JVM调优吹牛逼点
#### CMS:增加老年代内存 -XX:NewRatio 默认设置1:2 代表年轻代和老年代的占比为1:2
也可以直接设置-Xmn，表示新生代大小，如-Xmn=1g

#### CMS下通过增加新生代内存来降低full gc频率(设置-Xmn)

#### 使用压缩指针 -XX:+UseCompressedOops
