# 算法基础

## 二进制与32位
####
1.在java语言中，int类型数字都是以32位存储的二进制表示。

2.传统阿拉伯数字通常使用十进制表示，但二进制只有0和1。

3.java的int因为是有符号整数（正负数），因此32位支持范围是从-2^31 (-2,147,483,648) 到 2^31-1 (2,147,483,647) 

由于最高位则用来表示正负数，只能支持到2^31。不然它是可以支持到2^32的。

4.java的负数表示采用了第32位值为1，其他位置全取反再加1的表示方法。

```
比如整数5的32位表示为：
00000000000000000000000000000101

要表示-5则变成了

11111111111111111111111111111010
↓
11111111111111111111111111111011

```

# 时间复杂度
### 等差数列
n为数列总数，d为公差数, a1表示第一个数，an表示最后一个数

通项公式:
an=a1+(n-1)×d

前n项和公式：
Sn=na1+n×(n-1)×d/2或Sn=n×(a1+an)/2

$$ S_n = n \times a_1 + n \times (n - 1) \times \frac{d}{2} $$

$$ S_n = n \times a_1 + \left( n \times (n - 1) \times \frac{d}{2} \right) $$
$$ S_n = n \times a_1 + \frac{n \times (n - 1) \times d}{2}$$

### 对数

某个数需要乘以自身多少次才能得到另一个数。对数表示最终答案。

a: 基数
b: 真数
c: 对数

$$
log_a(b) = c
$$

举例:
如果问“2需要乘几次自己能得到8？”答案是3次，因为2 x 2 x 2 =8。

所以

$$
log_2(8) = 3
$$

如果问“数组要二分几次能找到某个N?”，也可以写成下面公式。

$$
log_2(N) = 次数
$$

<b>
对数定义：
如果2的N次方等于x, 则

$$ x = log_2N $$

</b>

举例：
假设初始有16个元素（N=16），我们来计算需要几次减半操作到达1：

第1次操作后，剩下8个元素。

第2次操作后，剩下4个元素。

第3次操作后，剩下2个元素。

第4次操作后，剩下1个元素。

可见，从16减少到1，需要4次操作，而
$$
log_2(16) = 4
$$
这验证了我们通过对数关系的预测。log2N次操作即可确定目标值的存在与否，使得算法的时间复杂度保持在非常低的O(log2N)水平。